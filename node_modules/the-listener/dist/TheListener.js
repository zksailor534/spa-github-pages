/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = addListener;

	var _detectIt = __webpack_require__(1);

	var _detectIt2 = _interopRequireDefault(_detectIt);

	var _eventMaps = __webpack_require__(6);

	var _detectPassiveSupport = __webpack_require__(7);

	var _detectPassiveSupport2 = _interopRequireDefault(_detectPassiveSupport);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * TouchState() constructor keeps track of the touch state for a target:
	 * time of the last touchstart, the time of the last touchend,
	 * and if the target is touched now, i.e. in touch active state
	 *
	 * @param {EventTarget}  target
	 * @return {TouchState}
	 */
	function TouchState(target) {
	  var _this = this;

	  this.start = undefined;
	  this.end = undefined;
	  this.active = false;
	  var options = _detectPassiveSupport2.default ? { passive: true, capture: true } : true;
	  target.addEventListener('touchstart', function () {
	    _this.start = new Date();_this.active = true;
	  }, options);
	  target.addEventListener('touchend', function () {
	    _this.end = new Date();_this.active = false;
	  }, options);
	  target.addEventListener('touchcancel', function () {
	    _this.end = new Date();_this.active = false;
	  }, options);
	}

	/**
	 * TouchStartState() constructor keeps track of only the touch start state for a target,
	 * the time of the last touchstart - this is used instead of TouchState when handling click
	 * events on a touchOnly device because no need to also track touchend time and touch active state
	 *
	 * @param {EventTarget}  target
	 * @return {TouchStartState}
	 */
	function TouchStartState(target) {
	  var _this2 = this;

	  this.start = undefined;
	  var options = _detectPassiveSupport2.default ? { passive: true, capture: true } : true;
	  target.addEventListener('touchstart', function () {
	    _this2.start = new Date();
	  }, options);
	}

	/**
	 * setTouchListener() sets a single touch listener for a specific target and event
	 *
	 * @param {Object}
	 *   @param {EventTarget} target
	 *   @param {String} event
	 *   @param {Function} handler
	 *   @param {Object or Boolean} listenerOptions
	 *   @param {TouchState} touchState (optional)
	 */
	function setTouchListener(_ref) {
	  var target = _ref.target;
	  var event = _ref.event;
	  var handler = _ref.handler;
	  var listenerOptions = _ref.listenerOptions;
	  var touchState = _ref.touchState;

	  // if the event is a known touch event, then set event listener
	  if (_eventMaps.touchEventsMap[event]) target.addEventListener(event, handler, listenerOptions);

	  // if the event is a click event, then call the handler on touchend if within 500ms of touchstart
	  else if (event === 'click') {
	      (function () {
	        // if no touchState, then create a new TouchStartState to keep track last touchstart time for 500ms click cutoff
	        var touch = touchState || new TouchStartState(target);
	        target.addEventListener('touchend', function (e) {
	          if (new Date() - touch.start < 500) handler(e);
	        }, listenerOptions);
	      })();
	    }
	}

	/**
	 * setMouseListener() sets a single mouse listener for a specific target and event
	 * note, this is called for mouseOnly devices - mouse event listeners for hybrid devices are set elsewhere
	 *
	 * @param {Object}
	 *   @param {EventTarget} target
	 *   @param {String} event
	 *   @param {Function} handler
	 *   @param {Object or Boolean} listenerOptions
	 */
	function setMouseListener(_ref2) {
	  var target = _ref2.target;
	  var event = _ref2.event;
	  var handler = _ref2.handler;
	  var listenerOptions = _ref2.listenerOptions;

	  // if the event is a known mouse event, then set the listener
	  if (_eventMaps.mouseEventsMap[event]) target.addEventListener(event, handler, listenerOptions);
	}

	/**
	 * setHybridListener() sets mouse and touch listeners for a specific target and event
	 *
	 * @param {Object}
	 *   @param {EventTarget} target
	 *   @param {String} event
	 *   @param {Function} handler
	 *   @param {Object or Boolean} listenerOptions
	 *   @param {TouchState} touchState
	 */
	function setHybridListener(_ref3) {
	  var target = _ref3.target;
	  var event = _ref3.event;
	  var handler = _ref3.handler;
	  var listenerOptions = _ref3.listenerOptions;
	  var touchState = _ref3.touchState;

	  // set touch listener
	  setTouchListener({ target: target, event: event, handler: handler, listenerOptions: listenerOptions, touchState: touchState });

	  // if the event is a known mouse event, then set the listener
	  if (_eventMaps.mouseEventsMap[event]) {
	    target.addEventListener(
	    /**
	     * Only call the handler if not in touch active state and the event occurred after 600ms
	     * from the last touchend event to prevent calling mouse handlers as a result of touch interactions.
	     * Based on testing, 600ms seems like sufficient time for all mouse events to fire after
	     * the last touchend event. Also, on some devices (notably Android) during a long press the mouse
	     * events will fire before touchend while actively touching the screen, so also need
	     * to makes sure not in the touch active state.
	     */
	    event, function (e) {
	      if (!touchState.active && new Date() - touchState.end > 600) handler(e);
	    }, listenerOptions);
	  }
	}

	/**
	 * setPointerListener() sets a single pointer listener for a specific target and event
	 *
	 * @param {Object}
	 *   @param {EventTarget} target
	 *   @param {String} event
	 *   @param {Function} handler
	 *   @param {Object or Boolean} listenerOptions
	 *   @param {Object} pointerOptions
	 */
	function setPointerListener(_ref4) {
	  var target = _ref4.target;
	  var event = _ref4.event;
	  var handler = _ref4.handler;
	  var listenerOptions = _ref4.listenerOptions;
	  var pointerOptions = _ref4.pointerOptions;

	  /**
	   * look up the pointer event that corresponds to the event argument (which is a mouse or touch event),
	   * note that at least one of ptrTouchEvent and ptrMouseEvent will be undefined
	   */
	  var ptrTouchEvent = _eventMaps.touchEventsMap[event];
	  var ptrMouseEvent = _eventMaps.mouseEventsMap[event];

	  // early return w/o setting a listener if pointerOptions says don't set listener for this specific pointer event
	  if (pointerOptions && (pointerOptions[ptrTouchEvent] === false || pointerOptions[ptrMouseEvent] === false)) return;

	  /**
	   * pointerType() returns the input type that created the event (mouse or touch),
	   * note that a pen pointer will be mapped to a touch input type
	   *
	   * @param {Event} e
	   * @return {String} 'mouse' or 'touch'
	   */
	  function pointerType(e) {
	    if (['touch', 2, 'pen', 3].indexOf(e.pointerType) !== -1) return 'touch';
	    if (['mouse', 4].indexOf(e.pointerType) !== -1) return 'mouse';
	    return undefined;
	  }

	  // access prefix function for pointer events
	  var pfix = _detectIt2.default.pointerEventsPrefix;

	  if (ptrMouseEvent === 'click' || ptrMouseEvent === 'dblclick') {
	    // if the event is a click or double click event, then set event listener with handler
	    target.addEventListener(ptrMouseEvent, handler, listenerOptions);
	  } else if (ptrMouseEvent) {
	    // if the event is a mouse event, then set pointer listener and only call the handler if pointType is a mouse
	    target.addEventListener(pfix(ptrMouseEvent), function (e) {
	      if (pointerType(e) === 'mouse') handler(e);
	    }, listenerOptions);
	  } else if (ptrTouchEvent) {
	    // if the event is a touch event, then set pointer listener and only call handler if pointType is touch or pen
	    target.addEventListener(pfix(ptrTouchEvent), function (e) {
	      if (pointerType(e) === 'touch') handler(e);
	    }, listenerOptions);
	  }
	}

	/**
	 * getListenerType() determines what function to use to set listeners based on the device type
	 *
	 * @return {Function} listener setter
	 */
	function getListenerType() {
	  var dIt = _detectIt2.default;
	  if (dIt.deviceType === 'mouseOnly') return setMouseListener;
	  if (dIt.deviceType === 'touchOnly' && dIt.hasTouchEventsApi) return setTouchListener;
	  if (dIt.deviceType === 'hybrid' && dIt.hasTouchEventsApi) return setHybridListener;
	  if (dIt.hasTouch && dIt.hasPointerEventsApi) return setPointerListener;
	  return function cantSetListeners() {};
	}

	/**
	 * getListenerOptions() returns the options argument for target.addEventListener(eventType, handler, options)
	 * based on if the browser supports passive event listeners - if the browser supports passive listeners
	 * then options can be an object, otherwise it is a boolean indicating a capture phase listener
	 *
	 * @param {Boolean} passive
	 * @param {Boolean} capture
	 * @return {Object or Boolean} addEventListener options argument
	 */
	function getListenerOptions(passive, capture) {
	  if (!passive || !_detectPassiveSupport2.default) return capture;
	  return { capture: capture, passive: passive };
	}

	/**
	 * parseKey() parses the key, which is a space separated string with events and options,
	 * and returns an object with events in an array and listenerOptions as either
	 * a boolean or an object (see getListenerOptions())
	 *
	 * @param {String} key, a space separated string containing events and options
	 * @return {Object} events: array, listenerOptions: either boolean or object
	 */
	function parseKey(key) {
	  var eventsAndOptions = key.split(' ');
	  return {
	    events: eventsAndOptions.filter(function (value) {
	      return value !== 'passive' && value !== 'capture';
	    }),
	    listenerOptions: getListenerOptions(eventsAndOptions.indexOf('passive') !== -1, eventsAndOptions.indexOf('capture') !== -1)
	  };
	}

	/**
	 * addListener() is the control center for setting listeners
	 *
	 * @param {EventTarget} target (required)
	 * @param {Object} eventsAndHandlers (required)
	 * @param {Object} pointerOptions (optional)
	 */
	function addListener(target, eventsAndHandlers, pointerOptions) {
	  // determine what function to use to set listeners based on type of device
	  var setListener = getListenerType();

	  // create new TouchState if need to keep track of touch state (only for hybrid devices)
	  var touchState = setListener === setHybridListener ? new TouchState(target) : undefined;

	  // parse the eventsAndHandlers object one key at a time
	  Object.keys(eventsAndHandlers).forEach(function (key) {
	    var handler = eventsAndHandlers[key];

	    var _parseKey = parseKey(key);

	    var events = _parseKey.events;
	    var listenerOptions = _parseKey.listenerOptions;

	    events.forEach(function (event) {
	      setListener({ target: target, event: event, handler: handler, listenerOptions: listenerOptions, touchState: touchState, pointerOptions: pointerOptions });
	    });
	  });
	}

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _detectHover = __webpack_require__(2);

	var _detectHover2 = _interopRequireDefault(_detectHover);

	var _detectPointer = __webpack_require__(3);

	var _detectPointer2 = _interopRequireDefault(_detectPointer);

	var _detectTouchEvents = __webpack_require__(4);

	var _detectTouchEvents2 = _interopRequireDefault(_detectTouchEvents);

	var _detectPointerEvents = __webpack_require__(5);

	var _detectPointerEvents2 = _interopRequireDefault(_detectPointerEvents);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/*
	 * detectIt object structure
	 * const detectIt = {
	 *   deviceType: 'mouseOnly' / 'touchOnly' / 'hybrid',
	 *   hasTouchEventsApi: boolean,
	 *   hasPointerEventsApi: boolean,
	 *   hasTouch: boolean,
	 *   maxTouchPoints: number,
	 *   primaryHover: 'hover' / 'none',
	 *   primaryPointer: 'fine' / 'coarse' / 'none',
	 *   state: {
	 *     detectHover,
	 *     detectPointer,
	 *     detectTouchEvents,
	 *     detectPointerEvents,
	 *   },
	 *   update() {...},
	 *   pointerEventsPrefix(value) {return value, value will only have prefix if requiresPrefix},
	 * }
	 */

	function robustMax(a, b) {
	  function isNum(value) {
	    return typeof value === 'number';
	  }
	  if (isNum(a) && isNum(b)) return Math.max(a, b);
	  if (isNum(a)) return a;
	  if (isNum(b)) return b;
	  return undefined;
	}

	function determineDeviceType(hasTouch, anyHover, anyFine) {
	  /*
	   * A hybrid device is one that both hasTouch and any input device can hover
	   * or has a fine pointer.
	   */
	  if (hasTouch && (anyHover || anyFine)) return 'hybrid';

	  /*
	   * In almost all cases a device that doesn’t support touch will have a mouse,
	   * but there may be rare exceptions. Note that it doesn’t work to do additional tests
	   * based on hover and pointer media queries as older browsers don’t support these.
	   * Essentially, 'mouseOnly' is the default.
	   */
	  return hasTouch ? 'touchOnly' : 'mouseOnly';
	}

	var detectIt = {
	  state: {
	    detectHover: _detectHover2.default,
	    detectPointer: _detectPointer2.default,
	    detectTouchEvents: _detectTouchEvents2.default,
	    detectPointerEvents: _detectPointerEvents2.default
	  },
	  update: function update() {
	    detectIt.state.detectHover.update();
	    detectIt.state.detectPointer.update();
	    detectIt.state.detectTouchEvents.update();
	    detectIt.state.detectPointerEvents.update();
	    detectIt.updateOnlyOwnProperties();
	  },
	  updateOnlyOwnProperties: function updateOnlyOwnProperties() {
	    if (typeof window !== 'undefined') {
	      detectIt.hasTouch = detectIt.state.detectTouchEvents.hasApi || detectIt.state.detectPointerEvents.hasTouch || false;

	      detectIt.deviceType = determineDeviceType(detectIt.hasTouch, detectIt.state.detectHover.anyHover, detectIt.state.detectPointer.anyFine);

	      detectIt.hasTouchEventsApi = detectIt.state.detectTouchEvents.hasApi;
	      detectIt.hasPointerEventsApi = detectIt.state.detectPointerEvents.hasApi;

	      detectIt.maxTouchPoints = robustMax(detectIt.state.detectTouchEvents.maxTouchPoints, detectIt.state.detectPointerEvents.maxTouchPoints);

	      detectIt.primaryHover = detectIt.state.detectHover.hover && 'hover' || detectIt.state.detectHover.none && 'none' ||
	      // if it's a mouseOnly device that doesn't support level 4 media queries,
	      // then assume it hovers
	      detectIt.deviceType === 'mouseOnly' && 'hover' ||
	      // if it's a touchOnly device that doesn't support level 4 media queries,
	      // then assume it doesn't hover, otherwise it's undefined
	      detectIt.deviceType === 'touchOnly' && 'none' || undefined;

	      detectIt.primaryPointer = detectIt.state.detectPointer.fine && 'fine' || detectIt.state.detectPointer.coarse && 'coarse' || detectIt.state.detectPointer.none && 'none' ||
	      // if it's a mouseOnly device that doesn't support level 4 media queries,
	      // then assume it has a fine pointer
	      detectIt.deviceType === 'mouseOnly' && 'fine' ||
	      // if it's a touchOnly device that doesn't support level 4 media queries,
	      // then assume it has a coarse pointer, otherwise it's undefined
	      detectIt.deviceType === 'touchOnly' && 'coarse' || undefined;
	    }
	  },

	  pointerEventsPrefix: _detectPointerEvents2.default.prefix
	};

	detectIt.updateOnlyOwnProperties();
	exports.default = detectIt;

/***/ },
/* 2 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var detectHover = {
	  update: function update() {
	    if (typeof window !== 'undefined' && typeof window.matchMedia === 'function') {
	      detectHover.hover = window.matchMedia('(hover: hover)').matches;
	      detectHover.none = window.matchMedia('(hover: none)').matches || window.matchMedia('(hover: on-demand)').matches;
	      detectHover.anyHover = window.matchMedia('(any-hover: hover)').matches;
	      detectHover.anyNone = window.matchMedia('(any-hover: none)').matches || window.matchMedia('(any-hover: on-demand)').matches;
	    }
	  }
	};

	detectHover.update();
	exports.default = detectHover;

/***/ },
/* 3 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var detectPointer = {
	  update: function update() {
	    if (typeof window !== 'undefined' && typeof window.matchMedia === 'function') {
	      detectPointer.fine = window.matchMedia('(pointer: fine)').matches;
	      detectPointer.coarse = window.matchMedia('(pointer: coarse)').matches;
	      detectPointer.none = window.matchMedia('(pointer: none)').matches;
	      detectPointer.anyFine = window.matchMedia('(any-pointer: fine)').matches;
	      detectPointer.anyCoarse = window.matchMedia('(any-pointer: coarse)').matches;
	      detectPointer.anyNone = window.matchMedia('(any-pointer: none)').matches;
	    }
	  }
	};

	detectPointer.update();
	exports.default = detectPointer;

/***/ },
/* 4 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var detectTouchEvents = {
	  update: function update() {
	    if (typeof window !== 'undefined') {
	      detectTouchEvents.hasApi = 'ontouchstart' in window;
	      detectTouchEvents.maxTouchPoints = detectTouchEvents.hasApi ? window.navigator && window.navigator.maxTouchPoints : undefined;
	    }
	  }
	};

	detectTouchEvents.update();
	exports.default = detectTouchEvents;

/***/ },
/* 5 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var prefixMap = {
	  pointerdown: 'MSPointerDown',
	  pointerup: 'MSPointerUp',
	  pointercancel: 'MSPointerCancel',
	  pointermove: 'MSPointerMove',
	  pointerover: 'MSPointerOver',
	  pointerout: 'MSPointerOut',
	  pointerenter: 'MSPointerEnter',
	  pointerleave: 'MSPointerLeave',
	  gotpointercapture: 'MSGotPointerCapture',
	  lostpointercapture: 'MSLostPointerCapture',
	  maxTouchPoints: 'msMaxTouchPoints'
	};

	/*
	 * detectPointerEvents object structure
	 * const detectPointerEvents = {
	 *   hasApi: boolean,
	 *   requiresPrefix: boolean,
	 *   hasTouch: boolean,
	 *   maxTouchPoints: number,
	 *   update() {...},
	 *   prefix(value) {return value, value will only have prefix if requiresPrefix === true},
	 * }
	 */
	var detectPointerEvents = {
	  update: function update() {
	    if (typeof window !== 'undefined') {
	      // reference for detection https://msdn.microsoft.com/en-us/library/dn433244(v=vs.85).aspx
	      if ('PointerEvent' in window) {
	        detectPointerEvents.hasApi = true;
	        detectPointerEvents.requiresPrefix = false;

	        // reference for detection https://msdn.microsoft.com/library/hh673557(v=vs.85).aspx
	      } else if (window.navigator && 'msPointerEnabled' in window.navigator) {
	        detectPointerEvents.hasApi = true;
	        detectPointerEvents.requiresPrefix = true;
	      } else {
	        detectPointerEvents.hasApi = false;
	        detectPointerEvents.requiresPrefix = undefined;
	      }
	      detectPointerEvents.maxTouchPoints = detectPointerEvents.hasApi && window.navigator && window.navigator[detectPointerEvents.prefix('maxTouchPoints')] || undefined;
	      detectPointerEvents.hasTouch = detectPointerEvents.hasApi ? detectPointerEvents.maxTouchPoints > 0 : undefined;
	    }
	  },
	  prefix: function prefix(value) {
	    return detectPointerEvents.requiresPrefix && prefixMap[value] || value;
	  }
	};

	detectPointerEvents.update();
	exports.default = detectPointerEvents;

/***/ },
/* 6 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var mouseEventsMap = {
	  click: 'click',
	  dblclick: 'dblclick',
	  mousedown: 'pointerdown',
	  mouseup: 'pointerup',
	  mouseenter: 'pointerenter',
	  mouseleave: 'pointerleave',
	  mouseover: 'pointerover',
	  mouseout: 'pointerout',
	  mousemove: 'pointermove'
	};

	var touchEventsMap = {
	  touchstart: 'pointerdown',
	  touchend: 'pointerup',
	  touchmove: 'pointermove',
	  touchcancel: 'pointercancel'
	};

	exports.mouseEventsMap = mouseEventsMap;
	exports.touchEventsMap = touchEventsMap;

/***/ },
/* 7 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	// adapted from https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md
	var passive = false;
	try {
	  var options = Object.defineProperty({}, 'passive', {
	    get: function get() {
	      passive = true;
	    }
	  });
	  window.addEventListener('test', null, options);
	} catch (e) {}

	var hasPassive = passive;
	exports.default = hasPassive;

/***/ }
/******/ ]);